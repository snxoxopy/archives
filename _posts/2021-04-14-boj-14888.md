---
title: "[Python] BOJ_14888 연산자 끼워넣기"
excerpt: "https://www.acmicpc.net/problem/14888"
toc: true
toc_sticky: true
toc_label: "Contents"

categories:
  - algorithm

tags:
  - python
---

### 풀이
1. 연산자가 들어갈 순열을 구한다.
</ol>
<ul>
<li>Pernutation -&gt;> nPn-1</li>
</ul>
<ol start="2">
<li>순열에 대한 계산 결과 반환</li>
</ol>
<h3 id="코드">코드</h3>
<h3 id="timeout">Timeout</h3>
<pre>

```python 
import sys  
from copy import deepcopy  
sys.stdin = open('input.txt','r')  
  n = int(input())  
num = list(map(int, input().split()))  
opr = list(map(int, input().split())) #덧셈(+)의 개수, 뺄셈(-)의 개수, 곱셈(×)의 개수, 나눗셈(÷)의 개수  
  oprs = []  
# 연산자 개수 -&gt; 값으로 변환  
for j in range(4):  
    for k in range(opr[j]):  
        oprs.append(j)  
  min_val = sys.maxsize  
max_val = -1 * sys.maxsize  
  def cal(operators):  
    global min_val, max_val  
  
    operand = num[0]  
    for i in range(len(operators)):  
        if operators[i] == 3:  
            if operand * num[i + 1] &lt; 0:  
                operand = -1 * (abs(operand) // abs(num[i+1]))  
        else:  
            operand //= num[i+1]  
        elif operators[i] == 2:  
            operand *= num[i + 1]  
        elif operators[i] == 1:  
            operand -= num[i + 1]  
            else:  
                operand += num[i + 1]  
  
    max_val = max(max_val, operand)  
    min_val = min(min_val, operand)  
  
  
picked = []  
  
  def comb_opr(operators):  
    if len(operators) == 0:  
        cal(picked)  
        return  
 else:  
        for e in operators:  
            deep_oprs = deepcopy(operators)  
            deep_oprs.remove(e)  
            picked.append(e)  
            comb_opr(deep_oprs)  
            picked.pop()  
  comb_opr(oprs)  
print(max_val)  
print(min_val)
```

<!--stackedit_data:
eyJoaXN0b3J5IjpbOTE5NDE3ODQwLC0xMDk5MzM3NjUzLC0xNT
MyMjk0MDcwXX0=
-->